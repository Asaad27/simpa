package tools;
import java.util.Collections;
import java.util.List;
import java.util.TreeMap;

import learner.efsm.LiConjecture;
import automata.State;
import automata.efsm.EFSMTransition;
import automata.efsm.Parameter;
import drivers.efsm.EFSMDriver.Types;

public class ASLanEntity {
	private String name;
	private TreeMap<String, String> arguments, symbols;
	private TreeMap<Types, String> mappingKITASLan;
	private String functions;
	
	public ASLanEntity(String name){
		this.name = name;
		arguments = new TreeMap<String, String>();
		addArgument("Actor", "agent");
		addArgument("Other", "agent");
		symbols = new TreeMap<String, String>();
		addSymbol("State", "nat");
		mappingKITASLan = new TreeMap<Types, String>();
		mappingKITASLan.put(Types.STRING, "text");
		mappingKITASLan.put(Types.NUMERIC, "int");
		mappingKITASLan.put(Types.NOMINAL, "text");
	}
	
	public void addSymbol(String name, String type){
		symbols.put(name,  type);
	}
	
	public void addArgument(String name, String type){
		arguments.put(name,  type);
	}
	
	public String toString(){
		String ent = header();
		ent += "specification SYSTEM_" + name.replace(" ", "_").toUpperCase() + "\n";
		ent += "channel_model CCM\n";
		ent += "\n";
		ent += "entity " + name.replace(" ", "_") + "(" + printArguments() + "){\n";
		ent +=    printSymbols();
		ent += "  body {\n";
		ent += "    State := 0;\n";
		ent += "    while (true){\n";
		ent += "      select {\n";
		ent +=          printFunctions();
		ent += "      }\n";
		ent += "    }\n";
		ent += "  }\n";
		ent += "}\n";
		return ent;
	}

	private String header() {
		return "%%%%%%%%%% Generated by KIT %%%%%%%%%%\n\n";
	}

	private String printFunctions() {
		return functions;
	}

	private String printSymbols() {
		if (symbols.isEmpty()) return "";
		else{
			String sym = "  symbols\n";
			for(String key : symbols.keySet()){
				sym += "    " + key + " : " + symbols.get(key) + ";\n";
			}			
			return sym;
		}
	}

	private String printArguments() {
		if (arguments.isEmpty()) return "";
		else{
			String arg = "";
			for(String key : arguments.keySet()){
				arg += key + " : " + arguments.get(key) + ", ";
			}			
			return arg.substring(0, arg.length()-2);
		}
	}

	public void loadFromEFSM(LiConjecture conjecture) {
		functions = "";
		conjecture.cleanMark();
		for(int i=0; i<conjecture.getStateCount(); i++){
			functions += "        on(State = " + i + "): {\n"; 
			writeState(conjecture, conjecture.getState(i));
			functions += "        }\n";
		}		
	}
	
	private void writeState(LiConjecture conjecture, State state) {
		functions += "          select {\n";
		for(String input : conjecture.getInputSymbols()){
			List<EFSMTransition> currentTrans = conjecture.getTransitionFromWithInput(state, input, true);
			if (!currentTrans.isEmpty()){
				List<String> paramNames = conjecture.getParamNames(currentTrans.get(0).getInput());
				functions += "            on(Other -> Actor: " + currentTrans.get(0).getInput() + "(";
				if (!paramNames.isEmpty()) functions += "?" + paramNames.get(0);
				for(int i=1; i<paramNames.size(); i++){
					functions += ", ?" + paramNames.get(i);
				}
				functions += ")): {\n";
				for(EFSMTransition t : currentTrans){
					String space = "              ";
					if (!conjecture.getLabelForTransition(t).getPredicates().isEmpty()){
						space += "  ";
						functions += "              if (";
						List<String> predicates = conjecture.getLabelForTransition(t).getPredicates();
						Collections.sort(predicates);
						functions += Utils.joinAndClean(predicates, " | ");
						functions += "){\n";
					}	
					
					for(Parameter p : conjecture.getLabelForTransition(t).getInput().getParameters()){
						symbols.put(p.value, mappingKITASLan.get(p.type));
					}
					
					for(String s : conjecture.getLabelForTransition(t).getOutputFunctions()){
						if (s.indexOf("=>") == -1){
							String[] value = s.split(" = ");
							if (value[1].startsWith("\"Ndv")) functions += space + value[0] + " := fresh();\n";
							else{
								try{
									Float.parseFloat(value[1].substring(1, value[1].length()-1));
									functions += space + value[0] + " := " + value[1].substring(1, value[1].length()-1).trim() + ";\n";
								}catch(NumberFormatException e){
									functions += space + value[0] + " := " + value[1].trim() + ";\n";
								}							
							}
						}else{
							String[] value1 = s.split(" => ");
							String[] value2 = value1[1].split(" = ");
							functions += space + "if (" + Utils.filter(value1[0]) + "){\n";
							functions += space + "  " + value2[0] + " := " + value2[1] + ";\n";
							functions += space + "}\n";
						}
					}

					functions += space + "Actor -> Other: " + conjecture.getLabelForTransition(t).getOutput() +";\n";

					for(Parameter p : conjecture.getLabelForTransition(t).getOutput().getParameters()){
						symbols.put(p.value, mappingKITASLan.get(p.type));
					}

					if (!conjecture.getLabelForTransition(t).getPredicates().isEmpty()){
						functions += "                State := " + t.getTo().getId() + "\n";
						functions += "              }\n";
					}else{
						functions += "              State := " + t.getTo().getId() + "\n";
					}
				}
				functions += "            }\n";
			}							
		}
		functions += "          }\n";
	}
}
